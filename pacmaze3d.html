
</script><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>TUC Graphics - PacMaze3D</title>

<!-- external libraries for matrix calculations and maintenance -->
<script type="text/javascript" src="./sandbox_files/glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="./sandbox_files/webgl-utils.js"></script>

<!-- Code for the vertex shader-->
<script id="shader-vs" type="x-shader/x-vertex">
attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    varying vec2 vTextureCoord;
    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aTextureCoord;
    }
</script>

<!-- Code for the fragment shader-->
<script id="shader-fs" type="x-shader/x-fragment">
    //necessary code for compatibility
	precision mediump float;

	//Variable coming from the vertex shader
    varying vec2 vTextureCoord;
    uniform sampler2D uSampler;
    void main(void) {
        gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
    }
</script>

<!-- Javascript code for the main functionality of the WebGL application-->
<script type="text/javascript">

    var gl;

    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
		} catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }
	
	var soundStart = true;
	function sound(){
		if (soundStart){
		
				soundStart = false;
					 window.AudioContext = (
				  window.AudioContext ||
				  window.webkitAudioContext ||
				  null
				);

				if (!AudioContext) {
				  throw new Error("AudioContext not supported!");
				} 

				// Create a new audio context.
				var ctx = new AudioContext();

				// Create a AudioGainNode to control the main volume.
				var mainVolume = ctx.createGain();
				// Connect the main volume node to the context destination.
				mainVolume.connect(ctx.destination);

				// Create an object with a sound source and a volume control.
				var sound = {};
				sound.source = ctx.createBufferSource();
				sound.volume = ctx.createGain();

				// Connect the sound source to the volume control.
				sound.source.connect(sound.volume);
				// Hook up the sound volume control to the main volume.
				sound.volume.connect(mainVolume);

				// Make the sound source loop.
				sound.source.loop = true;

				// Load a sound file using an ArrayBuffer XMLHttpRequest.
				var request = new XMLHttpRequest();
				request.open("GET", 'planet.mp3', true);
				request.responseType = "arraybuffer";
				request.onload = function(e) {

				  // Create a buffer from the response ArrayBuffer.
				  ctx.decodeAudioData(this.response, function onSuccess(buffer) {
					sound.buffer = buffer;

					// Make the sound source use the buffer and start playing it.
					sound.source.buffer = sound.buffer;
					sound.source.start(ctx.currentTime);
				  }, function onFailure() {
					alert("Decoding the audio buffer failed");
				  });
				};
				request.send();
		}
	}


	//Find and compile shaders (vertex + fragment shader)
    function getShader(gl, id) {
	//gets the shader scripts (vertex + fragment)
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
		//create shaders
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

		//ask WebGL to compile shaders
		//we check for errors here too
		//all errors are visible in the console (F12 in Google chrome)
        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }


	
    var shaderProgram;

	//Creates a program from a vertex + fragment shader pair
    function initShaders() {
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
		//link the compiled binaries
        gl.linkProgram(shaderProgram);

		//check for errors, again
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

		//activate current program
		//this sandbox has only on shader pair
		//we can have as many as we wish in more complex applications
        gl.useProgram(shaderProgram);

		//Update attributes for the vertex shader
		//attributes are accessible only from the vertex shader
		//if we want accessible data from a fragment shader we can use uniform variables,
		//or varyings that will be forwarded from the vertex shader to the fragment shader
		
		//Vertex position data
        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

		//Vertex color data
        shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
        gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

		//Update uniform variables
		//this variables can be accessed from both the vertex and fragment shader
        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
        shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
    }


	//ModelView and Projection matrices
	//mat4 comes from the external library
    var mvMatrix = mat4.create();
    var mvMatrixStack = [];
    var pMatrix = mat4.create();

	//The matrix stack operation are implemented below to handle local transformations
	
	//Push Matrix Operation
    function mvPushMatrix() {
        var copy = mat4.create();
        mat4.set(mvMatrix, copy);
        mvMatrixStack.push(copy);
    }

	//Pop Matrix Operation
    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
        mvMatrix = mvMatrixStack.pop();
    }


	//Sets + Updates matrix uniforms
    function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
    }


	//Rotation function helper
	function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }
	
	//---------------------------------------------------------------------------------
	//---------------------------------START CODE--------------------------------------
	
	//---------------------------------------------------------------------------------
	 function handleLoadedTexture(texture) {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }
	
	var wallTexture;
	var pathTexture;
	var powerUpTexture;
	
	var pelletTexture;
	var pacManTexture;
	
	var whiteTexture;
	var blueTexture;
	
	var redGhostTexture;
	var greenGhostTexture;
	var pinkGhostTexture;
	var yellowGhostTexture;
	
	
	function initTextures() {
        wallTexture = gl.createTexture();
        wallTexture.image = new Image();
        wallTexture.image.onload = function () {
            handleLoadedTexture(wallTexture)
        }

        wallTexture.image.src = "images/wall.jpg";
		
		pathTexture = gl.createTexture();
        pathTexture.image = new Image();
        pathTexture.image.onload = function () {
            handleLoadedTexture(pathTexture)
        }

        pathTexture.image.src = "images/path.jpg";
		
		powerUpTexture = gl.createTexture();
        powerUpTexture.image = new Image();
        powerUpTexture.image.onload = function () {
            handleLoadedTexture(powerUpTexture)
        }

        powerUpTexture.image.src = "images/powerup.jpg";
		
		whiteTexture = gl.createTexture();
        whiteTexture.image = new Image();
        whiteTexture.image.onload = function () {
            handleLoadedTexture(whiteTexture)
        }

        whiteTexture.image.src = "images/white.jpg";
		
		pacManTexture = gl.createTexture();
        pacManTexture.image = new Image();
        pacManTexture.image.onload = function () {
            handleLoadedTexture(pacManTexture)
        }

        pacManTexture.image.src = "images/pacman.jpg";
		
		redGhostTexture = gl.createTexture();
        redGhostTexture.image = new Image();
        redGhostTexture.image.onload = function () {
            handleLoadedTexture(redGhostTexture)
        }

        redGhostTexture.image.src = "images/red.jpg";
		
		greenGhostTexture = gl.createTexture();
        greenGhostTexture.image = new Image();
        greenGhostTexture.image.onload = function () {
            handleLoadedTexture(greenGhostTexture)
        }

        greenGhostTexture.image.src = "images/green.jpg";
		
		pinkGhostTexture = gl.createTexture();
        pinkGhostTexture.image = new Image();
        pinkGhostTexture.image.onload = function () {
            handleLoadedTexture(pinkGhostTexture)
        }

        pinkGhostTexture.image.src = "images/pink.jpg";
		
		yellowGhostTexture = gl.createTexture();
        yellowGhostTexture.image = new Image();
        yellowGhostTexture.image.onload = function () {
            handleLoadedTexture(yellowGhostTexture)
        }

        yellowGhostTexture.image.src = "images/yellow.jpg";
		
		blueTexture = gl.createTexture();
        blueTexture.image = new Image();
        blueTexture.image.onload = function () {
            handleLoadedTexture(blueTexture)
        }

        blueTexture.image.src = "images/blue.jpg";
		
		pelletTexture = gl.createTexture();
        pelletTexture.image = new Image();
        pelletTexture.image.onload = function () {
            handleLoadedTexture(pelletTexture)
        }

        pelletTexture.image.src = "images/pellet.jpg";
		
    }
	
	
	var basicPosition;
	var pathColor;
	var pacPosition;
	var pacColor;
	
	var cubeVertexPositionBuffer; 
    var cubeVertexColorBuffer; 
    var cubeVertexIndexBuffer; 
	
	var pyramidVertexPositionBuffer;
	var pyramidVertexColorBuffer;
	
	var powerPelletColor;
	
	var gGhostColor2;
	var gGhostColor1;
	
	var gGhostColor;
	var rGhostColor;
	var pGhostColor;
	var yGhostColor
	var cubeVertexTextureCoordBuffer;
	
	function initBuffers3d(){
	
	 cubeVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        vertices = [
            // Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,

            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,

            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,

            // Bottom face
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,

            // Right face
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,

            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        cubeVertexPositionBuffer.itemSize = 3;
        cubeVertexPositionBuffer.numItems = 24;

        cubeVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
        var textureCoords = [
          // Front face
          0.0, 0.0,
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,
          // Back face
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,
          0.0, 0.0,
          // Top face
          0.0, 1.0,
          0.0, 0.0,
          1.0, 0.0,
          1.0, 1.0,
          // Bottom face
          1.0, 1.0,
          0.0, 1.0,
          0.0, 0.0,
          1.0, 0.0,
          // Right face
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,
          0.0, 0.0,
          // Left face
          0.0, 0.0,
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
        cubeVertexTextureCoordBuffer.itemSize = 2;
        cubeVertexTextureCoordBuffer.numItems = 24;

        cubeVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        var cubeVertexIndices = [
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
       
		cubeVertexIndexBuffer.itemSize = 1;
        cubeVertexIndexBuffer.numItems = 36;
		
		//-----------------------------Path Position-------------------------------------
		
		basicPosition = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, basicPosition);
        vertices = [
             1.0,  1.0,  0.0,
            -1.0,  1.0,  0.0,
             1.0, -1.0,  0.0,
            -1.0, -1.0,  0.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        basicPosition.itemSize = 3;
        basicPosition.numItems = 4;
	
		//----------------------cube position buffer----------------------------------
        /*cubeVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        vertices = [
            // Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,

            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,

            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,

            // Bottom face
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,

            // Right face
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,

            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        cubeVertexPositionBuffer.itemSize = 3;
        cubeVertexPositionBuffer.numItems = 24;

		//----------------------cube colour buffer----------------------------------
		
        cubeVertexColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBuffer);
        colors = [
            [1.0, 1.0, 1.0, 1.0], // Front face
            [1.0, 1.0, 0.0, 1.0], // Back face
            [1.0, 0.0, 0.0, 1.0], // Top face
            [1.0, 0.5, 0.5, 1.0], // Bottom face
            [1.0, 0.0, 1.0, 1.0], // Right face
            [0.0, 0.0, 1.0, 1.0]  // Left face
        ];
        var unpackedColors = [];
        for (var i in colors) {
            var color = colors[i];
            for (var j=0; j < 4; j++) {
                unpackedColors = unpackedColors.concat(color);
            }
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
        cubeVertexColorBuffer.itemSize = 4;
        cubeVertexColorBuffer.numItems = 24;

		//----------------------cube index buffer----------------------------------
		
        cubeVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        var cubeVertexIndices = [
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
		cubeVertexIndexBuffer.itemSize = 1;
        cubeVertexIndexBuffer.numItems = 36;
		
		*/
		
		
		
		
		
		/*
		
		
		
		
		
		
		//------------------------GREEN GHOST-------------------------------------------
		gGhostColor = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, gGhostColor);
        colors = [
            [0.0, 1.0, 0.0, 1.0], // Front face
            [0.0, 1.0, 0.0, 1.0], // Back face
            [0.0, 1.0, 0.0, 1.0], // Top face
            [0.0, 1.0, 0.0, 1.0], // Bottom face
            [0.0, 1.0, 0.0, 1.0], // Right face
            [0.0, 1.0, 0.0, 1.0]  // Left face
        ];
        var unpackedColors = [];
        for (var i in colors) {
            var color = colors[i];
            for (var j=0; j < 4; j++) {
                unpackedColors = unpackedColors.concat(color);
            }
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
        gGhostColor.itemSize = 4;
        gGhostColor.numItems = 24;
		
		//------------------------GHOST blinking------------------------------------
		//------------------------white------------------------------------
		gGhostColor1 = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, gGhostColor1);
        colors = [
            [1.0, 1.0, 1.0, 1.0], // Front face
            [1.0, 1.0, 1.0, 1.0], // Back face
            [1.0, 1.0, 1.0, 1.0], // Top face
            [1.0, 1.0, 1.0, 1.0], // Bottom face
            [1.0, 1.0, 1.0, 1.0], // Right face
            [1.0, 1.0, 1.0, 1.0]  // Left face
        ];
        var unpackedColors = [];
        for (var i in colors) {
            var color = colors[i];
            for (var j=0; j < 4; j++) {
                unpackedColors = unpackedColors.concat(color);
            }
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
        gGhostColor1.itemSize = 4;
        gGhostColor1.numItems = 24;
		//------------------------------blue---------------------------------
		gGhostColor2 = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, gGhostColor2);
        colors = [
            [0.0, 0.0, 1.0, 1.0], // Front face
            [0.0, 0.0, 1.0, 1.0], // Back face
            [0.0, 0.0, 1.0, 1.0], // Top face
            [0.0, 0.0, 1.0, 1.0], // Bottom face
            [0.0, 0.0, 1.0, 1.0], // Right face
            [0.0, 0.0, 1.0, 1.0]  // Left face
        ];
        var unpackedColors = [];
        for (var i in colors) {
            var color = colors[i];
            for (var j=0; j < 4; j++) {
                unpackedColors = unpackedColors.concat(color);
            }
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
        gGhostColor2.itemSize = 4;
        gGhostColor2.numItems = 24;
		
		//------------------------RED GHOST-------------------------------------------
		rGhostColor = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, rGhostColor);
        colors = [
            [1.0, 0.0, 0.0, 1.0], // Front face
            [1.0, 0.0, 0.0, 1.0], // Back face
            [1.0, 0.0, 0.0, 1.0], // Top face
            [1.0, 0.0, 0.0, 1.0], // Bottom face
            [1.0, 0.0, 0.0, 1.0], // Right face
            [1.0, 0.0, 0.0, 1.0]  // Left face
        ];
        var unpackedColors = [];
        for (var i in colors) {
            var color = colors[i];
            for (var j=0; j < 4; j++) {
                unpackedColors = unpackedColors.concat(color);
            }
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
        rGhostColor.itemSize = 4;
        rGhostColor.numItems = 24;
		
		
		//------------------------PINK GHOST-------------------------------------------
		pGhostColor = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, pGhostColor);
        colors = [
            [1.0, 0.0, 1.0, 1.0], // Front face
            [1.0, 0.0, 1.0, 1.0], // Back face
            [1.0, 0.0, 1.0, 1.0], // Top face
            [1.0, 0.0, 1.0, 1.0], // Bottom face
            [1.0, 0.0, 1.0, 1.0], // Right face
            [1.0, 0.0, 1.0, 1.0]  // Left face
        ];
        var unpackedColors = [];
        for (var i in colors) {
            var color = colors[i];
            for (var j=0; j < 4; j++) {
                unpackedColors = unpackedColors.concat(color);
            }
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
        pGhostColor.itemSize = 4;
        pGhostColor.numItems = 24;
		
		
		//----------------------------YELLOW GHOST--------------------------------------
		yGhostColor = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, yGhostColor);
        colors = [
            [1.0, 0.7, 0.1, 1.0], // Front face
            [1.0, 0.7, 0.1, 1.0], // Back face
            [1.0, 0.7, 0.1, 1.0], // Top face
            [1.0, 0.7, 0.1, 1.0], // Bottom face
            [1.0, 0.7, 0.1, 1.0], // Right face
            [1.0, 0.7, 0.1, 1.0]  // Left face
        ];
        var unpackedColors = [];
        for (var i in colors) {
            var color = colors[i];
            for (var j=0; j < 4; j++) {
                unpackedColors = unpackedColors.concat(color);
            }
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
        yGhostColor.itemSize = 4;
        yGhostColor.numItems = 24;
		
		
		
		//----------------------POWER PELLET COLOR--------------------------------------
		powerPelletColor = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, powerPelletColor);
        colors = [
            [0.0, 0.0, 1.0, 1.0], // Front face
            [0.0, 0.0, 1.0, 1.0], // Back face
            [0.0, 0.0, 1.0, 1.0], // Top face
            [0.0, 0.0, 1.0, 1.0], // Bottom face
            [0.0, 0.0, 1.0, 1.0], // Right face
            [0.0, 0.0, 1.0, 1.0]  // Left face
        ];
        var unpackedColors = [];
        for (var i in colors) {
            var color = colors[i];
            for (var j=0; j < 4; j++) {
                unpackedColors = unpackedColors.concat(color);
            }
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
        powerPelletColor.itemSize = 4;
        powerPelletColor.numItems = 24;
		
		
			
		
		
		//-----------------------------Path Colour-------------------------------------
		
		pathColor = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, pathColor);
        var colors = [
            0.0, 0.0, 0.0, 1.0,
            0.0, 0.0, 0.0, 1.0,
            0.0, 0.0, 0.0, 1.0,
			0.0, 0.0, 0.0, 1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
        pathColor.itemSize = 4;
        pathColor.numItems = 4;
		
		
		//--------------------AAAAAAAAAAAAAAAAAA--------------------------
		//------------------pacman pyramida---------------------------------
		pyramidVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexPositionBuffer);
        var vertices = [
            // Front face
             0.0,  1.0,  0.0,
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,

            // Right face
             0.0,  1.0,  0.0,
             1.0, -1.0,  1.0,
             1.0, -1.0, -1.0,

            // Back face
             0.0,  1.0,  0.0,
             1.0, -1.0, -1.0,
            -1.0, -1.0, -1.0,

            // Left face
             0.0,  1.0,  0.0,
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        pyramidVertexPositionBuffer.itemSize = 3;
        pyramidVertexPositionBuffer.numItems = 12;
		
		 pyramidVertexColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexColorBuffer);
        var colors = [
            // Front face
            1.0, 0.0, 0.0, 1.0,
            0.0, 1.0, 0.0, 1.0,
            0.0, 0.0, 1.0, 1.0,

            // Right face
            1.0, 0.0, 0.0, 1.0,
            0.0, 0.0, 1.0, 1.0,
            0.0, 1.0, 0.0, 1.0,

            // Back face
            1.0, 0.0, 0.0, 1.0,
            0.0, 1.0, 0.0, 1.0,
            0.0, 0.0, 1.0, 1.0,

            // Left face
            1.0, 0.0, 0.0, 1.0,
            0.0, 0.0, 1.0, 1.0,
            0.0, 1.0, 0.0, 1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
        pyramidVertexColorBuffer.itemSize = 4;
        pyramidVertexColorBuffer.numItems = 12;


        cubeVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        vertices = [
            // Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,

            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,

            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,

            // Bottom face
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,

            // Right face
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,

            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        cubeVertexPositionBuffer.itemSize = 3;
        cubeVertexPositionBuffer.numItems = 24;

        cubeVertexColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBuffer);
        colors = [
            [1.0, 0.0, 0.0, 1.0], // PANW
            [1.0, 0.0, 0.0, 1.0], // KATW
            [0.0, 0.0, 1.0, 1.0], // pros ta panw
            [0.0, 0.0, 1.0, 1.0], // pros ta katw
            [0.0, 0.0, 1.0, 1.0], // pros ta deksia
            [0.0, 0.0, 1.0, 1.0]  // pros ta aristera
        ];
        var unpackedColors = [];
        for (var i in colors) {
            var color = colors[i];
            for (var j=0; j < 4; j++) {
                unpackedColors = unpackedColors.concat(color);
            }
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
        cubeVertexColorBuffer.itemSize = 4;
        cubeVertexColorBuffer.numItems = 24;

        cubeVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        var cubeVertexIndices = [
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
        cubeVertexIndexBuffer.itemSize = 1;
        cubeVertexIndexBuffer.numItems = 36;		
		
		
		//-------------------------------Pac------------------------------------
		//-----------------------------------------------------------------------
		//-------------------------2D - not used--------------------------------
		//-------------------------------PacPosition----------------------------
		pacPosition = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, pacPosition);
        var vertices = [
             0.0,  1.0,  0.0,
            -1.0, -1.0,  0.0,
             1.0, -1.0,  0.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        pacPosition.itemSize = 3;
        pacPosition.numItems = 3;

		
		//--------------------------------PacColor----------------------------------
        pacColor = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, pacColor);
        var colors = [
            1.0, 1.0, 0.0, 1.0,
            1.0, 1.0, 0.0, 1.0,
            1.0, 1.0, 0.0, 1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
        pacColor.itemSize = 4;
        pacColor.numItems = 3;
		*/
	}
	
	
	
	
	
	var pista = ["x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x",
				 "p","p","p","p","p","x","p","p","p","p","p","p","p","x","p","p","p","p","p",
				 "x","x","x","x","p","x","p","x","x","x","x","x","p","x","p","x","x","x","x",
				 "x","p","p","p","p","p","p","p","p","x","p","p","p","p","p","p","p","p","x",
				 "x","p","x","x","p","x","x","x","p","x","p","x","x","x","p","x","x","p","x", //exw kai 2 U se afti ti grammi
				 "x","p","p","x","p","p","p","p","p","p","p","p","p","p","p","x","p","p","x",
				 "x","x","p","x","p","x","p","x","x","x","x","x","p","x","p","x","p","x","x",
				 "x","p","p","p","p","x","p","p","p","x","p","p","p","x","p","p","p","p","x",
				 "x","p","x","x","x","x","x","x","p","x","p","x","x","x","x","x","x","p","x",
				 "x","p","p","p","p","x","p","p","p","p","p","p","p","x","p","p","p","p","x",
				 "x","x","x","x","p","x","p","x","x","x","x","x","p","x","p","x","x","x","x",
				 "x","p","p","p","p","p","p","p","p","x","p","p","p","p","p","p","p","p","x",
				 "x","p","x","x","p","x","x","x","p","x","p","x","x","x","p","x","x","p","x", //exw kai 2 U se afti ti grammi
				 "x","p","p","x","p","p","p","p","p","p","p","p","p","p","p","x","p","p","x",
				 "x","x","p","x","p","x","p","x","x","x","x","x","p","x","p","x","p","x","x",
				 "x","p","p","p","p","x","p","p","p","x","p","p","p","x","p","p","p","p","x",
				 "x","p","x","x","x","x","x","x","p","x","p","x","x","x","x","x","x","p","x",
				 "x","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","x",
				 "x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x"
				];
				

	var pellets =   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
					 0,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,
					 0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,
					 0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,
					 0,2,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,2,0, //e0w kai 2 U se afti ti grammi
					 0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,
					 0,0,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,0,
					 0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0,
					 0,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,0,
					 0,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,0,
					 0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,
					 0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,
					 0,2,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,2,0, //e0w kai 2 U se afti ti grammi
					 0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,
					 0,0,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,0,
					 0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0,
					 0,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,0,
					 0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
					 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
					];
					
					//174 pellets kai 4 powerups
				
	var positionArray = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
						 ];	
						 
	var ghostArray =    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
						 ];					 
	
	
	var pistatest =		 ["x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x",
					  "p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p",
				   	  "x","x","x","p","x","x","p","x","x","p","x","x","p","x","x","p","x","x","x",
					  "x","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","x",
					  "x","x","x","p","x","x","p","x","x","p","x","x","p","x","x","p","x","x","x",
					  "x","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","x",
					  "x","x","x","p","x","x","p","x","x","p","x","x","p","x","x","p","x","x","x",
					  "x","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","x",
					  "x","x","x","p","x","x","p","x","x","p","x","x","p","x","x","p","x","x","x",
					  "x","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","x",
					  "x","x","x","p","x","x","p","x","x","p","x","x","p","x","x","p","x","x","x",
					  "x","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","x",
					  "x","x","x","p","x","x","p","x","x","p","x","x","p","x","x","p","x","x","x",
					  "x","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","x",
					  "x","x","x","p","x","x","p","x","x","p","x","x","p","x","x","p","x","x","x",
					  "x","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","x",
					  "x","x","x","p","x","x","p","x","x","p","x","x","p","x","x","p","x","x","x",
					  "x","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","x",
					  "x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x","x"
					];	
					
				
				
				
	var pelletstest =  	[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
					  0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
				   	  0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,
					  0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
					  0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,
					  0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,0,
					  0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,
					  0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
					  0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,
					  0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
					  0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,
					  0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
					  0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,
					  0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,0,
					  0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,
					  0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
					  0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,
					  0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,
					  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
					];	
					//190 pellets 4 power ups	
	

	//--------------pinakes arxikopoihseis thesis kai fantamaston------------------

	var positionArraytest = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
						 ];		

    var ghostArraytest =  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
						 ];							 

	
	
	
	function drawPista3d(){
	
		gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
		mat4.identity(mvMatrix);
		mat4.translate(mvMatrix, [-20.0, 19.0, -50.0]);
	
	
		for (i = 0; i < 400; i++){
			if  ((i != 0)&&(i % 19 ==0)){
				mat4.translate(mvMatrix, [-38.0, -2.0, 0.0]);
			}
			mat4.translate(mvMatrix, [2.0, 0.0, 0.0]);
			

			//--------------------------------walls-------------------------------------
			if (pista[i] == "x"){
			
				gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
				gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
				
				gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, wallTexture);
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
				//gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBuffer);
				//gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, cubeVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
			
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
			   
				setMatrixUniforms();
				gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
			
			}
			
			//--------------------------------pellets-------------------------------------
			if (pellets[i] == 1){	
			
				mat4.scale(mvMatrix, [0.2, 0.2, 0.2 ]);
				
				gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
				gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
				
				
				gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, pelletTexture);
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
				//gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBuffer);
				//gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, cubeVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
			
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
			   
				setMatrixUniforms();
				gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
				
				mat4.scale(mvMatrix, [5.0, 5.0, 5.0 ]);
			}
			
			if ((pista[i] == "p") || (pista[i] == "U")) {
			//--------------------------------paths-------------------------------------
				gl.bindBuffer(gl.ARRAY_BUFFER, basicPosition);
				gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, basicPosition.itemSize, gl.FLOAT, false, 0, 0);
			   
			   
			   gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, pathTexture);
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
				//gl.bindBuffer(gl.ARRAY_BUFFER, pathColor);
				//gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, pathColor.itemSize, gl.FLOAT, false, 0, 0);

			   
				setMatrixUniforms();
				gl.drawArrays(gl.TRIANGLE_STRIP, 0, basicPosition.numItems);
			}
			
			//-----------------------------------power pellet-----------------------------
			if (pellets[i] == 2){	
				mat4.scale(mvMatrix, [0.5, 0.5, 0.5 ]);
				
				gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
				gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
				
				 gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, powerUpTexture);
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
				

				//gl.bindBuffer(gl.ARRAY_BUFFER, powerPelletColor);
				//gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, powerPelletColor.itemSize, gl.FLOAT, false, 0, 0);
			
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
			   
				setMatrixUniforms();
				gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
				
				mat4.scale(mvMatrix, [2.0, 2.0, 2.0 ]);
			}
		}
	}
	
	//-------------------------------DRAW GREEN GHOST--------------------------------
	var gBlinkCounter = 0;	
	
	function drawGreenGhost(){
		gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
		mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
		mat4.identity(mvMatrix);
		
		if (swapcam == 1){
			mat4.translate(mvMatrix, [16.0, 9.3, -49.9]);
			mvPushMatrix();
			mat4.translate(mvMatrix, [gXTrans, gYTrans, 0.0]);
		}
		if (swapcam == 2){
			mat4.translate(mvMatrix, [32, -1.0, -29.9]);
			mat4.rotate(mvMatrix,degToRad(45),[1,0,0]);
			
			mvPushMatrix();
			mat4.translate(mvMatrix, [2-xTrans+gXTrans, -0.15*(yTrans-gYTrans), 8+yTrans-gYTrans]);
		}
		
		mat4.scale(mvMatrix, [0.7, 0.7, 0.7 ]);
		gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
		gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
		
		if (!(powerActive)){
		
					gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, greenGhostTexture);
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
		//greenGhostTexture
			//gl.bindBuffer(gl.ARRAY_BUFFER, gGhostColor);
			//gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, gGhostColor.itemSize, gl.FLOAT, false, 0, 0);
		}

		if (powerActive){
			gBlinkCounter += 1;
			
			if (gBlinkCounter <20){
			
			gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, whiteTexture);
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
				//gl.bindBuffer(gl.ARRAY_BUFFER, gGhostColor1);
				//gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, gGhostColor1.itemSize, gl.FLOAT, false, 0, 0);
				
			}
			if (gBlinkCounter >= 20){
						gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, blueTexture);
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
				//gl.bindBuffer(gl.ARRAY_BUFFER, gGhostColor2);
				//gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, gGhostColor2.itemSize, gl.FLOAT, false, 0, 0);
			}
			if (gBlinkCounter>40){
				gBlinkCounter = 0;
			}
		}
		
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
		setMatrixUniforms();
		gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
	
	}
	
	//-------------------------------DRAW RED GHOST--------------------------------
	var rBlinkCounter = 0;	
	
	function drawRedGhost(){
		gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
		mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
		mat4.identity(mvMatrix);
		
		if (swapcam == 1){
			mat4.translate(mvMatrix, [-16.0, 9.3, -49.9]);
			mvPushMatrix();
			mat4.translate(mvMatrix, [rXTrans, rYTrans, 0.0]);
		}	
			
		if (swapcam == 2){
			mat4.translate(mvMatrix, [0, -1.0, -29.9]);
			mat4.rotate(mvMatrix,degToRad(45),[1,0,0]);
			
			mvPushMatrix();
			mat4.translate(mvMatrix, [2-xTrans+rXTrans, -0.15*(yTrans-rYTrans), 8+yTrans-rYTrans]);
		}
		
		mat4.scale(mvMatrix, [0.7, 0.7, 0.7 ]);
		gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
		gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
			
		if (!(powerActive)){
					gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, redGhostTexture);
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
			//gl.bindBuffer(gl.ARRAY_BUFFER, rGhostColor);
			//gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, rGhostColor.itemSize, gl.FLOAT, false, 0, 0);
		}

		if (powerActive){
			rBlinkCounter += 1;
			
			if (rBlinkCounter <20){		
					gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, whiteTexture);
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
				//gl.bindBuffer(gl.ARRAY_BUFFER, gGhostColor1);
				//gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, gGhostColor1.itemSize, gl.FLOAT, false, 0, 0);
			}
			if (rBlinkCounter >= 20){
					gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, blueTexture);
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
				//gl.bindBuffer(gl.ARRAY_BUFFER, gGhostColor2);
				//gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, gGhostColor2.itemSize, gl.FLOAT, false, 0, 0);
			}
			if (rBlinkCounter>40){
				rBlinkCounter = 0;
			}
		}
		
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
		setMatrixUniforms();
		gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		mvPopMatrix();	
	
	}
	
	//-------------------------------DRAW PINK GHOST--------------------------------
	var pBlinkCounter = 0;	
	
	function drawPinkGhost(){
		gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
		mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
		mat4.identity(mvMatrix);
		
		if (swapcam == 1){
			mat4.translate(mvMatrix, [-16.0, -7.3, -49.9]);
			mvPushMatrix();
			mat4.translate(mvMatrix, [pXTrans, pYTrans, 0.0]);
		}
		if (swapcam == 2){
			mat4.translate(mvMatrix, [0, -1.0, -29.9]);
			mat4.rotate(mvMatrix,degToRad(45),[1,0,0]);
			
			mvPushMatrix();
			mat4.translate(mvMatrix, [2-xTrans+pXTrans, -3-0.15*(yTrans-pYTrans), 16+8+yTrans-pYTrans]);
		}
		
		mat4.scale(mvMatrix, [0.7, 0.7, 0.7 ]);
		gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
		gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
		
		if (!(powerActive)){
		gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, pinkGhostTexture);
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
			//gl.bindBuffer(gl.ARRAY_BUFFER, pGhostColor);
			//gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, pGhostColor.itemSize, gl.FLOAT, false, 0, 0);
		}

		if (powerActive){
			pBlinkCounter += 1;
			
			if (pBlinkCounter <20){
			gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, whiteTexture);
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
				//gl.bindBuffer(gl.ARRAY_BUFFER, gGhostColor1);
				//gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, gGhostColor1.itemSize, gl.FLOAT, false, 0, 0);
				}
			if (pBlinkCounter >= 20){
			gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, blueTexture);
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
				//gl.bindBuffer(gl.ARRAY_BUFFER, gGhostColor2);
				//gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, gGhostColor2.itemSize, gl.FLOAT, false, 0, 0);
				}
			if (pBlinkCounter>40){
				pBlinkCounter = 0;
			}
		}
		
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
		setMatrixUniforms();
		gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
	
	}
	
	//-------------------------------DRAW YELLOW GHOST--------------------------------
	var yBlinkCounter = 0;	
	
	function drawYellowGhost(){
		gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
		mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
		mat4.identity(mvMatrix);
		
		if (swapcam == 1){
			mat4.translate(mvMatrix, [16.0, -7.3, -49.9]);
			mvPushMatrix();
			mat4.translate(mvMatrix, [yXTrans, yYTrans, 0.0]);
		}
		if (swapcam == 2){
			mat4.translate(mvMatrix, [32, -1.0, -29.9]);
			mat4.rotate(mvMatrix,degToRad(45),[1,0,0]);
			
			mvPushMatrix();
			mat4.translate(mvMatrix, [2-xTrans+yXTrans, -3-0.15*(yTrans-yYTrans), 16+8+yTrans-yYTrans]);
		}
		
		mat4.scale(mvMatrix, [0.7, 0.7, 0.7 ]);
		
		gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
		gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
		
		if (!(powerActive)){
		gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, yellowGhostTexture);
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
			//gl.bindBuffer(gl.ARRAY_BUFFER, yGhostColor);
			//gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, yGhostColor.itemSize, gl.FLOAT, false, 0, 0);
			}

		if (powerActive){
			yBlinkCounter += 1;
			
			if (pBlinkCounter <20){
			gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, whiteTexture);
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
				//gl.bindBuffer(gl.ARRAY_BUFFER, gGhostColor1);
				//gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, gGhostColor1.itemSize, gl.FLOAT, false, 0, 0);
				}
			if (yBlinkCounter >= 20){
			gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, blueTexture);
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
				//gl.bindBuffer(gl.ARRAY_BUFFER, gGhostColor2);
				//gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, gGhostColor2.itemSize, gl.FLOAT, false, 0, 0);
				}
			if (yBlinkCounter>40){
				yBlinkCounter = 0;
			}
		}
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
		setMatrixUniforms();
		gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
	
	}
	
	
	
	function drawPac(){
		
		gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        //gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

        mat4.identity(mvMatrix);
		mat4.translate(mvMatrix, [-18.0, 17.3, -49.9]);
		
		
		mvPushMatrix();
		
		mat4.translate(mvMatrix, [xTrans, yTrans, 0.0]);
		mat4.scale(mvMatrix, [0.8, 0.8, 0.8 ]);
		mat4.rotate(mvMatrix, degToRad(90), [1, 0, 0]);
		
		
		
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
		gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
		
		gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
		gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, pacManTexture);
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        //gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexColorBuffer);
        //gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, pyramidVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
		setMatrixUniforms();
		gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
	
	
		mvPopMatrix();
	}
	
	
	
	
	function drawPistaFollow() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
		  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

        mat4.identity(mvMatrix);
		
	
		mat4.translate(mvMatrix, [0, 0, -30.0]);
		mat4.rotate(mvMatrix,degToRad(55),[1,0,0]);
		
		
	
	
		mvPushMatrix();
		
		mat4.scale(mvMatrix, [0.65, 0.65, 0.65 ]);
		
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
		
		
		gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, pacManTexture);
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        //gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexColorBuffer);
        //gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, pyramidVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
		
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, cubeVertexPositionBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		
		mvPopMatrix();
		
	
		
		for (i = 0; i < 400; i++){
			if (i == 0){
				mat4.translate(mvMatrix, [-2-xTrans, 0.0, -2+yTrans]);
			}
			if ((i !=0) && (i % 19 ==0)){
				mat4.translate(mvMatrix, [-38.0, 0.0, 2.0]);
			}
			mat4.translate(mvMatrix, [2.0, 0.0, 0.0]);
			
			
		
			
			//----------------------------------toixoi----------------------
			if (pista[i] == "x"){
				mat4.rotate(mvMatrix,degToRad(90),[1,0,0]);
				gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
				gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
				
				
				gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, wallTexture);
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
				//gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBuffer);
				//gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, cubeVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
			
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
			   
				setMatrixUniforms();
				gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
				mat4.rotate(mvMatrix,degToRad(-90),[1,0,0]);
			}
				//---------------------------pellets------------------------------
				
				if (pellets[i] == 1){	
				mat4.scale(mvMatrix, [0.1, 0.1, 0.1 ]);
				
				
				gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
				gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
				
				gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, pelletTexture);
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
				//gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBuffer);
				//gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, cubeVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
			
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
				setMatrixUniforms();
				gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
				
				mat4.scale(mvMatrix, [10.0, 10.0, 10.0 ]);
			}
			
			if ((pista[i] == "p") || (pista[i] == "U")) {
			//--------------------------------paths-------------------------------------
						
			
			
			
			mat4.translate(mvMatrix, [0.0, -1.0, 0.0]);
			mat4.rotate(mvMatrix,degToRad(90),[1,0,0]);
				gl.bindBuffer(gl.ARRAY_BUFFER, basicPosition);
				gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, basicPosition.itemSize, gl.FLOAT, false, 0, 0);
			   
			   gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, pathTexture);
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
				//gl.bindBuffer(gl.ARRAY_BUFFER, pathColor);
				//gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, pathColor.itemSize, gl.FLOAT, false, 0, 0);

				setMatrixUniforms();
				gl.drawArrays(gl.TRIANGLE_STRIP, 0, basicPosition.numItems);
				mat4.rotate(mvMatrix,degToRad(-90),[1,0,0]);
				mat4.translate(mvMatrix, [0.0, 1.0, 0.0]);
			}
			
			//-----------------------------------power pellet-----------------------------
			if (pellets[i] == 2){	
				mat4.scale(mvMatrix, [0.5, 0.5, 0.5 ]);
				
				gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
				gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
				
				gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, powerUpTexture);
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
				//gl.bindBuffer(gl.ARRAY_BUFFER, powerPelletColor);
				//gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, powerPelletColor.itemSize, gl.FLOAT, false, 0, 0);
			
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
			   
				setMatrixUniforms();
				gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
				
				mat4.scale(mvMatrix, [2.0, 2.0, 2.0 ]);
			}
			
			
		}
				
	}
			
	
	
	function drawScene(){
				if (swapcam == 1){
					drawPista3d();
					drawPac();	
					if (!(greenEaten)){
						drawGreenGhost();
					}
					if (!(redEaten)){
					drawRedGhost();
					}
					if (!(pinkEaten)){
					drawPinkGhost();
					}
					if (!(yellowEaten)){
					drawYellowGhost();
					}
				}
				if (swapcam == 2){
					drawPistaFollow();
					if (!(greenEaten)){
						drawGreenGhost();
					}
					if (!(redEaten)){
					drawRedGhost();
					}
					if (!(pinkEaten)){
					drawPinkGhost();
					}
					if (!(yellowEaten)){
					drawYellowGhost();
					}
				}
			
		}
			
	var notick = false;
	
	var leftPressed = false;
	var rightPressed = false;
	var upPressed = false;
	var downPressed = false;
	
	
	var qleftPressed = false;
	var qrightPressed = false;
	var qupPressed = false;
	var qdownPressed = false;
		
	
	var xTrans = 0.0;
	var yTrans = 0.0;
	
	var index = 0;
		
	var rightBlocked = false;
	var leftBlocked = false;
	var downBlocked = false;
	var upBlocked = false;
	
	var lives = 3;
	var score = 0;
	var initialPellets = 174;
	var remainingPellets = 174;
	var levelcomplete = false;
	
	var ypTrans = 0;
	var xpTrans = 0;
	

	
	var grn = 0;
	var gIndex = 0;
	var gleft = 0;
	var gright = 0;
	var gup = 0;
	var gdown = 0;
	var gXTrans = 0;
	var gYTrans = 0;
	var greenEaten = false;
	var gmove = 0;
	var gMovement = true;
	
	var rrn = 0;
	var rIndex = 0;
	var rleft = 0;
	var rright = 0;
	var rup = 0;
	var rdown = 0;
	var rXTrans = 0;
	var rYTrans = 0;
	var redEaten = false;
	var rmove = 0;
	var rMovement = true;
	
	var prn = 0;
	var pIndex = 0;
	var pleft = 0;
	var pright = 0;
	var pup = 0;
	var pdown = 0;
	var pXTrans = 0;
	var pYTrans = 0;
	var pinkEaten = false;
	var pmove = 0;
	var pMovement = true;
	
	var yrn = 0;
	var yIndex = 0;
	var yleft = 0;
	var yright = 0;
	var yup = 0;
	var ydown = 0;
	var yXTrans = 0;
	var yYTrans = 0;
	var yellowEaten = false;
	var ymove = 0;
	var yMovement = true;
		
	//var lastCheck = 0;
	//var pelletcount = 0;
	
	var powerActive = false;
	var timerActive = 0;
	
	
	
	function gameLogic(){
	
	
		//-------------------------entopismos thesis pacman-------------------------
		for (i = 0; i < 400; i++){
			if (positionArray[i] == 1){
				index = i;
			}
		}
		
		//--------------------periorismoi------------------------
		//--------------------deksia-----------------------------		
		if (pista[index+1] == "x"){
			rightBlocked = true;
		}
		if (pista[index+1] == "p"){
			rightBlocked = false;
		}
		
		//--------------------aristera-----------------------------	
		//if (index!=19){			//mallon tha thelei elegxo kai gia tis upoloipes grammes
			if (pista[index-1] == "x") {
				leftBlocked = true;
			}
			if (pista[index-1] == "p"){
				leftBlocked = false;
			}
		//}
		
		//--------------------katw-----------------------------	
		if (pista[index+19] == "x")  {
			downBlocked = true;
		}
		if (pista[index+19] == "p") {
			downBlocked = false;
		}
		
		//--------------------panw-----------------------------	
		if (pista[index-19] == "x")  {
			upBlocked = true;
		}
		if (pista[index-19] == "p") {
			upBlocked = false;
		}
		
		
		
		//------------------kinisi ston x------------------------
		//------------------pros ta deksia-----------------------
		
		if (pista[index+1] == "p" ){
			if (xpTrans > 2){
				positionArray[index] = 0;
				positionArray[index+1] = 1;
				if (pellets[index+1] == 1){
					pellets[index+1] = 0;
					score += 10;
					remainingPellets -= 1;
				}
				if (pellets[index+1] == 2){
					pellets[index+1] = 0;
					powerActive = true;
				}
				xpTrans = 0;
			}
		}
		
		//--------------------pros ta aristera------------------------
		if (pista[index-1] == "p" ){
			if (xpTrans < -2){
				positionArray[index] = 0;
				positionArray[index-1] = 1;
				if (pellets[index-1] == 1){
					pellets[index-1] = 0;
					score += 10;
					remainingPellets -= 1;
				}
				if (pellets[index-1] == 2){
					pellets[index-1] = 0;
					powerActive = true;
				}
				xpTrans = 0;
			}
		}
		
		if ((index == 19) && (leftPressed)){
			index = 37;
			positionArray[19] = 0;
			positionArray[index] = 1;
			if (pellets[37] == 1){
					pellets[37] = 0;
					score += 10;
					remainingPellets -= 1;
				}
			xTrans=36;
		}
		
		if ((index == 37) && (rightPressed)){
			index = 19;
			positionArray[37] = 0;
			positionArray[index] = 1;
			if (pellets[19] == 1){
					pellets[19] = 0;
					score += 10;
					remainingPellets -= 1;
				}
			xTrans= 0;
		}
		
		
		
	
		
		//------------------kinisi ston y------------------------
		//------------------pros ta katw-------------------------
		
		
		if (pista[index+19] == "p"){	
			if (ypTrans < -2){
				positionArray[index] = 0;
				positionArray[index+19] = 1;
				if (pellets[index+19] == 1){
					pellets[index+19] = 0;
					score += 10;
					remainingPellets -= 1;
				}
				if (pellets[index+19] == 2){
					pellets[index+19] = 0;
					powerActive = true;
				}
				ypTrans = 0;
			}
		}
		
		//------------------pros ta panw-------------------------
		if (pista[index-19] == "p"){	
			if (ypTrans > 2){
				positionArray[index] = 0;
				positionArray[index-19] = 1;
				if (pellets[index-19] == 1){
					pellets[index-19] = 0;
					score += 10;
					remainingPellets -= 1;
				}
				if (pellets[index-19] == 2){
					pellets[index-19] = 0;
					powerActive = true;
				}
				ypTrans = 0;
			}
		}
		
		//------------------------fantasmata---------------------------
		//------------------------entopismos theseon tous--------------
		for (i = 0; i < 400; i++){
			if (ghostArray[i] == 1){
				gIndex = i;
			}
			if (ghostArray[i] == 2){
				rIndex = i;
			}
			if (ghostArray[i] == 3){
				pIndex = i;
			}
			if (ghostArray[i] == 4){
				yIndex = i;
			}
		}
		//-------------------------kinisi tous----------------------------
		//-------------------------prasino------------------------------
		if(!(greenEaten)){
			grn = Math.random();
			if (gMovement){
				if (grn < 0.25) {
					gmove = 1;
				}
				if ((grn >= 0.25) && (grn < 0.5)){
					gmove = 2;
				}
				if ((grn >= 0.5) && (grn < 0.75)){
					gmove = 3;
				}
				if (grn >= 0.75) {
					gmove = 4;
				}
			}
			
			if ((gmove == 1) && (pista[gIndex-1]=="p")){
				gXTrans -= 0.1;
				gleft -= 0.1;
				gMovement = false;
				if (gleft < -2){
					ghostArray[gIndex] = 0;
					ghostArray[gIndex-1] = 1;
					gleft = 0;
					gMovement = true;
				}
			}
			
			if ((gmove == 2) && (pista[gIndex+1]=="p")){
				gXTrans += 0.1;
				gright += 0.1;
				gMovement = false;
				if (gright > 2){
					ghostArray[gIndex] = 0;
					ghostArray[gIndex+1] = 1;
					gright = 0;
					gMovement = true;
				}
			}
			
			if ((gmove == 3) && (pista[gIndex-19]=="p")){
				gYTrans += 0.1;
				gup += 0.1;
				gMovement = false;
				if (gup > 2){
					ghostArray[gIndex] = 0;
					ghostArray[gIndex-19] = 1;
					gup = 0;
					gMovement = true;
				}
			}
			
			if ((gmove == 4) && (pista[gIndex+19]=="p")){
				gYTrans -= 0.1;
				gdown -= 0.1;
				gMovement = false;
				if (gdown < -2){
					ghostArray[gIndex] = 0;
					ghostArray[gIndex+19] = 1;
					gdown = 0;
					gMovement = true;
				}
			}
		}
		
		//------------------------------kokkino-----------------------------------
		if(!(redEaten)){
			rrn = Math.random();
			if (rMovement){
				if (rrn < 0.25) {
					rmove = 1;
				}
				if ((rrn >= 0.25) && (rrn < 0.5)){
					rmove = 2;
				}
				if ((rrn >= 0.5) && (rrn < 0.75)){
					rmove = 3;
				}
				if (rrn >= 0.75) {
					rmove = 4;
				}
			}
			
			if ((rmove == 1) && (pista[rIndex-1]=="p")){
				rXTrans -= 0.1;
				rleft -= 0.1;
				rMovement = false;
				if (rleft < -2){
					ghostArray[rIndex] = 0;
					ghostArray[rIndex-1] = 2;
					rleft = 0;
					rMovement = true;
				}
			}
			
			if ((rmove == 2) && (pista[rIndex+1]=="p")){
				rXTrans += 0.1;
				rright += 0.1;
				rMovement = false;
				if (rright > 2){
					ghostArray[rIndex] = 0;
					ghostArray[rIndex+1] = 2;
					rright = 0;
					rMovement = true;
				}
			}
			
			if ((rmove == 3) && (pista[rIndex-19]=="p")){
				rYTrans += 0.1;
				rup += 0.1;
				rMovement = false;
				if (rup > 2){
					ghostArray[rIndex] = 0;
					ghostArray[rIndex-19] = 2;
					rup = 0;
					rMovement = true;
				}
			}
			
			if ((rmove == 4) && (pista[rIndex+19]=="p")){
				rYTrans -= 0.1;
				rdown -= 0.1;
				rMovement = false;
				if (rdown < -2){
					ghostArray[rIndex] = 0;
					ghostArray[rIndex+19] = 2;
					rdown = 0;
					rMovement = true;
				}
			}
		}
		
		//------------------------------roz-----------------------------------
		if(!(pinkEaten)){
			prn = Math.random();
			if (pMovement){
				if (prn < 0.25) {
					pmove = 1;
				}
				if ((prn >= 0.25) && (prn < 0.5)){
					pmove = 2;
				}
				if ((prn >= 0.5) && (prn < 0.75)){
					pmove = 3;
				}
				if (prn >= 0.75) {
					pmove = 4;
				}
			}
			
			if ((pmove == 1) && (pista[pIndex-1]=="p")){
				pXTrans -= 0.1;
				pleft -= 0.1;
				pMovement = false;
				if (pleft < -2){
					ghostArray[pIndex] = 0;
					ghostArray[pIndex-1] = 3;
					pleft = 0;
					pMovement = true;
				}
			}
			
			if ((pmove == 2) && (pista[pIndex+1]=="p")){
				pXTrans += 0.1;
				pright += 0.1;
				pMovement = false;
				if (pright > 2){
					ghostArray[pIndex] = 0;
					ghostArray[pIndex+1] = 3;
					pright = 0;
					pMovement = true;
				}
			}
			
			if ((pmove == 3) && (pista[pIndex-19]=="p")){
				pYTrans += 0.1;
				pup += 0.1;
				pMovement = false;
				if (pup > 2){
					ghostArray[pIndex] = 0;
					ghostArray[pIndex-19] = 3;
					pup = 0;
					pMovement = true;
				}
			}
			
			if ((pmove == 4) && (pista[pIndex+19]=="p")){
				pYTrans -= 0.1;
				pdown -= 0.1;
				pMovement = false;
				if (pdown < -2){
					ghostArray[pIndex] = 0;
					ghostArray[pIndex+19] = 3;
					pdown = 0;
					pMovement = true;
				}
			}
		}
		
		//------------------------------kitrino-----------------------------------
		if(!(yellowEaten)){
			yrn = Math.random();
			if (yMovement){
				if (yrn < 0.25) {
					ymove = 1;
				}
				if ((yrn >= 0.25) && (yrn < 0.5)){
					ymove = 2;
				}
				if ((yrn >= 0.5) && (yrn < 0.75)){
					ymove = 3;
				}
				if (yrn >= 0.75) {
					ymove = 4;
				}
			}
			
			if ((ymove == 1) && (pista[yIndex-1]=="p")){
				yXTrans -= 0.1;
				yleft -= 0.1;
				yMovement = false;
				if (yleft < -2){
					ghostArray[yIndex] = 0;
					ghostArray[yIndex-1] = 4;
					yleft = 0;
					yMovement = true;
				}
			}
			
			if ((ymove == 2) && (pista[yIndex+1]=="p")){
				yXTrans += 0.1;
				yright += 0.1;
				yMovement = false;
				if (yright > 2){
					ghostArray[yIndex] = 0;
					ghostArray[yIndex+1] = 4;
					yright = 0;
					yMovement = true;
				}
			}
			
			if ((ymove == 3) && (pista[yIndex-19]=="p")){
				yYTrans += 0.1;
				yup += 0.1;
				yMovement = false;
				if (yup > 2){
					ghostArray[yIndex] = 0;
					ghostArray[yIndex-19] = 4;
					yup = 0;
					yMovement = true;
				}
			}
			
			if ((ymove == 4) && (pista[yIndex+19]=="p")){
				yYTrans -= 0.1;
				ydown -= 0.1;
				yMovement = false;
				if (ydown < -2){
					ghostArray[yIndex] = 0;
					ghostArray[yIndex+19] = 4;
					ydown = 0;
					yMovement = true;
				}
			}
		}
		
		
		
		//---------------------------------xasimo------------------------------------
		if (!(powerActive)){
			if (index == rIndex){
				lives = lives - 1;
				if (lives == 0){
					notick = true;
				}
				
				for (i = 0; i < 400; i++){
					positionArray[i] = 0;				
				}
				xTrans = 0;
				yTrans = 0;
				xpTrans = 0;
				ypTrans = 0;
				positionArray[19] = 1;
				downPressed = false;
				upPressed = false;
				rightPressed = false;
				leftPressed = false;
				qdownPressed = false;
				qupPressed = false;
				qrightPressed = false;
				qleftPressed = false;
				rMovement = true;
			}
			
			if (index == gIndex){
				lives = lives - 1;
				if (lives == 0){
					notick = true;
				}
				
				for (i = 0; i < 400; i++){
					positionArray[i] = 0;
					//ghostArray[i] = 0;					
				}
				xTrans = 0;
				yTrans = 0;
				xpTrans = 0;
				ypTrans = 0;
				positionArray[19] = 1;
				downPressed = false;
				upPressed = false;
				rightPressed = false;
				leftPressed = false;
				qdownPressed = false;
				qupPressed = false;
				qrightPressed = false;
				qleftPressed = false;
				gMovement = true;
			}
			
			if (index == pIndex){
				lives = lives - 1;
				if (lives == 0){
					notick = true;
				}
				
				for (i = 0; i < 400; i++){
					positionArray[i] = 0;
					//ghostArray[i] = 0;					
				}
				xTrans = 0;
				yTrans = 0;
				xpTrans = 0;
				ypTrans = 0;
				positionArray[19] = 1;
				downPressed = false;
				upPressed = false;
				rightPressed = false;
				leftPressed = false;
				qdownPressed = false;
				qupPressed = false;
				qrightPressed = false;
				qleftPressed = false;
				pMovement = true;
			}
			if (index == yIndex){
				lives = lives - 1;
				if (lives == 0){
					notick = true;
				}
				
				for (i = 0; i < 400; i++){
					positionArray[i] = 0;
					//ghostArray[i] = 0;					
				}
				xTrans = 0;
				yTrans = 0;
				xpTrans = 0;
				ypTrans = 0;
				positionArray[19] = 1;
				downPressed = false;
				upPressed = false;
				rightPressed = false;
				leftPressed = false;
				qdownPressed = false;
				qupPressed = false;
				qrightPressed = false;
				qleftPressed = false;
				yMovement = true;
			}
		}
		
		//---------------------------fagoma fantasmaton------------------------------
		//---------prasino------------
		if (powerActive){
			if (index == gIndex){
				for (i=0;i<400;i++){
					if (ghostArray[i]==1){
						ghostArray[i] = 0;
						gIndex = 0;
						score += 100;
					}
				}
				greenEaten = true;
			}
		}
		
		//---------kokkino------------
		if (powerActive){
			if (index == rIndex){
				for (i=0;i<400;i++){
					if (ghostArray[i]==2){
						ghostArray[i] = 0;
						rIndex = 0;
						score += 100;
					}
				}
				redEaten = true;
			}
		}
		//---------roz------------
		if (powerActive){
			if (index == pIndex){
				for (i=0;i<400;i++){
					if (ghostArray[i]==3){
						ghostArray[i] = 0;
						pIndex = 0;
						score += 100;
					}
				}
				pinkEaten = true;
			}
		}
		//---------kitrino---------
		if (powerActive){
			if (index == yIndex){
				for (i=0;i<400;i++){
					if (ghostArray[i]==4){
						ghostArray[i] = 0;
						yIndex = 0;
						score += 100;
					}
				}
				yellowEaten = true;
			}
		}
		
		
				//---------------------------power pellet timer-----------------------------
		var timeNow = new Date().getTime();
		if (!(powerActive)){
			timerActive =  timeNow;
		}
		//----------------------respawn prasinou----------------------
		if (powerActive){
			var elapsed = timeNow - timerActive;
		}
		if ((elapsed > 20000) && (greenEaten)){
			powerActive = false;
			ghostArray[112] = 1;
			gXTrans = 0;
			gYTrans = 0;
			gleft = 0;
			gdown = 0;
			gup = 0;
			gright = 0;
			gMovement = true;
			greenEaten = false;
		}
		
		if ((elapsed > 20000) && (!greenEaten)){
			powerActive = false;
			greenEaten = false;
		}
		
		//----------------------respawn kokkinou----------------------
		
		if ((elapsed > 20000) && (redEaten)){
			powerActive = false;
			ghostArray[96] = 2;
			rXTrans = 0;
			rYTrans = 0;
			rleft = 0;
			rdown = 0;
			rup = 0;
			rright = 0;
			rMovement = true;
			redEaten = false;
		}
		
		if ((elapsed > 20000) && (!redEaten)){
			powerActive = false;
			redEaten = false;
		}
		
		//----------------------respawn roz----------------------
		
		if ((elapsed > 20000) && (pinkEaten)){
			powerActive = false;
			ghostArray[248] = 3;
			pXTrans = 0;
			pYTrans = 0;
			pleft = 0;
			pdown = 0;
			pup = 0;
			pright = 0;
			pMovement = true;
			pinkEaten = false;
		}
		
		if ((elapsed > 20000) && (!pinkEaten)){
			powerActive = false;
			pinkEaten = false;
		}
		
		//----------------------respawn kitrino----------------------
		
		if ((elapsed > 20000) && (yellowEaten)){
			powerActive = false;
			ghostArray[264] = 4;
			yXTrans = 0;
			yYTrans = 0;////
			yleft = 0;
			ydown = 0;
			yup = 0;
			yright = 0;
			yMovement = true;
			yellowEaten = false;
		}
		
		if ((elapsed > 20000) && (!yellowEaten)){
			powerActive = false;
			yellowEaten = false;
		}
		
		
			
			//----------------------oloklirosi level----------------------------------
		
		
		if (remainingPellets == 0){
			levelcomplete = true;
		}
		
		
	}
	
	
	
	
	var currentlyPressedKeys = {};

    function handleKeyDown(event) {
        currentlyPressedKeys[event.keyCode] = true;

        if (String.fromCharCode(event.keyCode) == "F") {
            filter += 1;
            if (filter == 3) {
                filter = 0;
            }
        }
    }

    function handleKeyUp(event) {
        currentlyPressedKeys[event.keyCode] = false;
    }

	
	var swapcam = 1;
	
	function handleKeys() {
	
		if (currentlyPressedKeys[49]){
			swapcam = 1;
		}
		if (currentlyPressedKeys[50]){
			swapcam = 2;
		}
		
		// Left
        if (  (!leftBlocked) && (currentlyPressedKeys[37]) && (!currentlyPressedKeys[39]) && (!currentlyPressedKeys[40]) && (!currentlyPressedKeys[38])){
			leftPressed = true;
		    rightPressed = false;
			upPressed = false;
			downPressed = false;
        }
		
         // Right
        if (  (!rightBlocked) && (currentlyPressedKeys[39]) && (!currentlyPressedKeys[37]) && (!currentlyPressedKeys[40]) && (!currentlyPressedKeys[38])){
			leftPressed = false;
		    rightPressed = true;
			upPressed = false;
			downPressed = false;
        }
		
        // Up 
        if ( (!upBlocked) && (currentlyPressedKeys[38]) && (!currentlyPressedKeys[37]) && (!currentlyPressedKeys[40]) && (!currentlyPressedKeys[39])){
			leftPressed = false;
		    rightPressed = false;
			upPressed = true;
			downPressed = false;
        }
				
        // Down 
        if ( (!downBlocked) &&    (currentlyPressedKeys[40]) && (!currentlyPressedKeys[37]) && (!currentlyPressedKeys[39]) && (!currentlyPressedKeys[38])){
			leftPressed = false;
		    rightPressed = false;
			upPressed = false;
			downPressed = true;
        }
		
		if ((leftPressed) && (!leftBlocked))  {
			xTrans -= 0.1;
			xpTrans -= 0.1;	
			

			if (currentlyPressedKeys[40]){
				qdownPressed = true;		
			}
			if (currentlyPressedKeys[38]){
				qupPressed = true;		
			}
			
		}
		if ((rightPressed) && (!rightBlocked)){
			xTrans += 0.1;
			xpTrans += 0.1;
			
			if (currentlyPressedKeys[40]){
				qdownPressed = true;		
			}
			if (currentlyPressedKeys[38]){
				qupPressed = true;		
			}
		}
		if ((upPressed)  && (!upBlocked)) {
			yTrans += 0.1;
			ypTrans += 0.1;
			
			if (currentlyPressedKeys[39]){
				qrightPressed = true;		
			}
			if (currentlyPressedKeys[37]){
				qleftPressed = true;		
			}
			
		}
		if ((downPressed) && (!downBlocked)){
			yTrans -= 0.1;
			ypTrans -= 0.1;
			
			if (currentlyPressedKeys[39]){
				qrightPressed = true;		
			}
			if (currentlyPressedKeys[37]){
				qleftPressed = true;		
			}
		}
		
		//-----------------------mnimi gia to deksia-aristera-------------------------
		if ((qdownPressed) && (!downBlocked)){
				downPressed = true;
				leftPressed = false;
				rightPressed = false;
				qdownPressed = false;
		}
		if ((qupPressed) && (!upBlocked)){
				upPressed = true;
				leftPressed = false;
				rightPressed = false;
				qupPressed = false;
		}
		
		//-----------------------mnimi gia to panw katw------------------------------
		if ((qrightPressed) && (!rightBlocked)){
				rightPressed = true;
				upPressed = false;
				downPressed = false;
				qrightPressed = false;
		}
		if ((qleftPressed) && (!leftBlocked)){
				leftPressed = true;
				upPressed = false;
				downPressed = false;
				qleftPressed = false;
		}
		
    }
	
	
	var gameComplete = false;
	
	var audio = new Audio('planet.mp3');
	
	function tick(){
		if ((!(notick)) && (!(levelcomplete))){
			requestAnimFrame(tick);
			//sound();
			handleKeys();
			gameLogic();
			updateDashBoard();
			drawScene();
			audio.play();
		}
		if (notick){
			drawGameLost();
		}
		if ((levelcomplete) && (!gameComplete)){
			requestAnimFrame(tick);
			drawLevelComplete();
			
			positionArray = positionArraytest;
			pellets = pelletstest;
			ghostArray = ghostArraytest;
			pista = pistatest;
			
			initialPellets = 190;
			remainingPellets = 190;
			
			xTrans = 0;
			yTrans = 0;
			ypTrans = 0;
			xpTrans = 0;
			
			gXTrans = 0;
			gYTrans = 0;
			gleft = 0;
			gright = 0;
			gup = 0;
			gdown = 0;
			gMovement = true;
			greenEaten = false;
			
			rXTrans = 0;
			rYTrans = 0;
			rleft = 0;
			rright = 0;
			rup = 0;
			rdown = 0;
			rMovement = true;
			redEaten = false;
			
			pXTrans = 0;
			pYTrans = 0;
			pleft = 0;
			pright = 0;
			pup = 0;
			pdown = 0;
			pMovement = true;
			pinkEaten = false;
			
			yXTrans = 0;
			yYTrans = 0;
			yleft = 0;
			yright = 0;
			yup = 0;
			ydown = 0;
			yMovement = true;
			yellowEaten = false;
			
			downPressed = false;
			upPressed = false;
			rightPressed = false;
			leftPressed = false;
			qdownPressed = false;
			qupPressed = false;
			qrightPressed = false;
			qleftPressed = false;
			
			powerActive = false;
			
			if (currentlyPressedKeys[32]){
				gameComplete = true;
				levelcomplete = false;
			}
		}
		if ((levelcomplete) && (gameComplete)){
			drawGameWon();
		}
		
	}
	
	function updateDashBoard() {
    	document.getElementById("lives_id").innerHTML = lives;
    	document.getElementById("score_id").innerHTML = score;
		document.getElementById("remainingPellets_id").innerHTML = remainingPellets;
    }
	
	
	function webGLStart() {
        var canvas = document.getElementById("TUCWebGL");
        
		initGL(canvas);
        initShaders()
        initBuffers3d();
		initTextures();

		//Background Color: Color assigned for all pixels with no corresponding fragments
        gl.clearColor(0.0, 0.0, 0.0, 0.0);
		
		//Enable z-buffer for depth sorting
        gl.enable(gl.DEPTH_TEST);

		//define the keyboard handlers
		document.onkeydown = handleKeyDown;
		document.onkeyup = handleKeyUp;
		
        tick();
    }
	
	
	var lcArray = 		[1,0,0,0,1,1,1,0,1,0,0,0,1,0,1,1,1,0,1,0,0,
						 1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,
						 1,0,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,0,
						 1,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,
						 1,1,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 1,1,1,0,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,
						 1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,1,
						 1,1,1,0,1,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0,1,
						 1,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
						 1,0,0,0,1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1
						 ];
	
	function drawLevelComplete(){
		
		gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

        mat4.identity(mvMatrix);
		mat4.translate(mvMatrix, [-16.0, 9.3, -30.0]);
		mat4.scale(mvMatrix, [0.7, 0.7, 0.7 ]);
		
		for (i = 0; i < 231; i++){
		
		
			if (i==21){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			if (i == 42){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			if (i == 63){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			if (i == 84){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);;
			}
			if (i == 105){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			if (i == 126){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			if (i == 147){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			if (i == 168){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			if (i == 189){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			if (i == 200){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			
	
			mat4.translate(mvMatrix, [2.0, 0.0, 0.0]);
		
			if (lcArray[i] == 1){
				gl.bindBuffer(gl.ARRAY_BUFFER, basicPosition);
				gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, basicPosition.itemSize, gl.FLOAT, false, 0, 0);
			   
			   gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, wallTexture);
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
				//gl.bindBuffer(gl.ARRAY_BUFFER, pathColor);
				//gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, pathColor.itemSize, gl.FLOAT, false, 0, 0);

			   
				setMatrixUniforms();
				gl.drawArrays(gl.TRIANGLE_STRIP, 0, basicPosition.numItems);
			}
		}
	}
	
	var lostArray = 	[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,1,1,0,
						 0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,0,0,
						 0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,0,0,
						 0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,
						 0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
						 ];
	
	function drawGameLost(){
		
		gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

        mat4.identity(mvMatrix);
		mat4.translate(mvMatrix, [-16.0, 9.3, -30.0]);
		mat4.scale(mvMatrix, [0.7, 0.7, 0.7 ]);
		
		for (i = 0; i < 231; i++){
		
		
			if (i==21){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			if (i == 42){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			if (i == 63){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			if (i == 84){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);;
			}
			if (i == 105){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			if (i == 126){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			if (i == 147){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			if (i == 168){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			if (i == 189){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			if (i == 200){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			
	
			mat4.translate(mvMatrix, [2.0, 0.0, 0.0]);
		
			if (lostArray[i] == 1){
				gl.bindBuffer(gl.ARRAY_BUFFER, basicPosition);
				gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, basicPosition.itemSize, gl.FLOAT, false, 0, 0);
			   
			   
			   gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, wallTexture);
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
				//gl.bindBuffer(gl.ARRAY_BUFFER, pathColor);
				//gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, pathColor.itemSize, gl.FLOAT, false, 0, 0);

			   
				setMatrixUniforms();
				gl.drawArrays(gl.TRIANGLE_STRIP, 0, basicPosition.numItems);
			}
		}
	}
	
	var wonArray = 		[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,1,0,0,0,0,0,1,0,1,1,1,0,1,0,0,0,1,0,0,
						 0,0,1,0,0,0,0,0,1,0,1,0,1,0,1,1,0,0,1,0,0,
						 0,0,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,
						 0,0,0,1,0,1,0,1,0,0,1,0,1,0,1,0,0,1,1,0,0,
						 0,0,0,0,1,0,1,0,0,0,1,1,1,0,1,0,0,0,1,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
						 ];
	
	function drawGameWon(){
		
		gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

        mat4.identity(mvMatrix);
		mat4.translate(mvMatrix, [-16.0, 9.3, -30.0]);
		mat4.scale(mvMatrix, [0.7, 0.7, 0.7 ]);
		
		for (i = 0; i < 231; i++){
		
		
			if (i==21){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			if (i == 42){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			if (i == 63){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			if (i == 84){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);;
			}
			if (i == 105){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			if (i == 126){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			if (i == 147){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			if (i == 168){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			if (i == 189){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			if (i == 200){
			mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
			mat4.translate(mvMatrix, [-42.0, -2.0, 0.0]);
			}
			
	
			mat4.translate(mvMatrix, [2.0, 0.0, 0.0]);
		
			if (wonArray[i] == 1){
				gl.bindBuffer(gl.ARRAY_BUFFER, basicPosition);
				gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, basicPosition.itemSize, gl.FLOAT, false, 0, 0);
			   
			   
			   gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, wallTexture);
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
				//gl.bindBuffer(gl.ARRAY_BUFFER, pathColor);
				//gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, pathColor.itemSize, gl.FLOAT, false, 0, 0);

			   
				setMatrixUniforms();
				gl.drawArrays(gl.TRIANGLE_STRIP, 0, basicPosition.numItems);
			}
		}
	}
	
	
	
	
	
	//---------------------------------------------------------------------------------
	//---------------------------------------------------------------------------------
	//---------------------------------------------------------------------------------
	//--------------------------END CODE-----------------------------------------------
	//---------------------------------------------------------------------------------
	//---------------------------------------------------------------------------------
	//---------------------------------------------------------------------------------
	//---------------------------------------------------------------------------------
	//---------------------------------------------------------------------------------
	//---------------------------------------------------------------------------------
	//---------------------------------------------------------------------------------
	//---------------------------------------------------------------------------------
	//---------------------------------------------------------------------------------
	//---------------------------------------------------------------------------------
	//---------------------------------------------------------------------------------
	//---------------------------------------------------------------------------------
	//---------------------------------------------------------------------------------
	//---------------------------------------------------------------------------------
	//---------------------------------------------------------------------------------
	//---------------------------------------------------------------------------------
	//---------------------------------------------------------------------------------
	
	
	
	
	
	
	//var lastTime = 0;

	//var counter = 0.0;
	//Animate function
    function animate() {
       // var timeNow = new Date().getTime();
        if (lastTime != 0) {
           // var elapsed = timeNow - lastTime;

			//adjust a constant rotation speed independently of platform/framerate
            rCube -= (75 * elapsed) / 1000.0;
			
			counter += elapsed;
			if (counter > 1000.0){
				movDirection = !movDirection;
				counter = 0;
				}
			if (movDirection)
				swinging += (1 * elapsed) / 1000.0;
			else 
				swinging -= (1 * elapsed) / 1000.0;
				
			
        }
        lastTime = timeNow;
    }
	
	
	
	
	//Vertex, Index and Color Data
   // var cubeVertexPositionBuffer; // contains coordinates
   // var cubeVertexColorBuffer; //contains color per vertex
   // var cubeVertexIndexBuffer; //contains indices for chains of vertices to draw triangles/other geometry

	//Initialize VBOs, IBOs and color
    function initBuffers2() {
        //Vertex Buffer Object
        cubeVertexPositionBuffer = gl.createBuffer();
		//Bind buffer to ARRAY_BUFFER
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        vertices = [
            // Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,

            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,

            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,

            // Bottom face
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,

            // Right face
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,

            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
		//every item has 3 coordinates (x,y,z)
        cubeVertexPositionBuffer.itemSize = 3;
		//we have 24 vertices
        cubeVertexPositionBuffer.numItems = 24;

		//Color
        cubeVertexColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBuffer);
        colors = [
            [1.0, 0.0, 0.0, 1.0], // Front face
            [1.0, 1.0, 0.0, 1.0], // Back face
            [0.0, 1.0, 0.0, 1.0], // Top face
            [1.0, 0.5, 0.5, 1.0], // Bottom face
            [1.0, 0.0, 1.0, 1.0], // Right face
            [0.0, 0.0, 1.0, 1.0]  // Left face
        ];
        var unpackedColors = [];
        for (var i in colors) {
            var color = colors[i];
			//assign colors for each vertex of each face based on the packed representation above
            for (var j=0; j < 4; j++) {
                unpackedColors = unpackedColors.concat(color);
            }
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
		//every color has 4 values: red, green, blue and alpha (transparency: use 1.0 (opaque) for this demo)
        cubeVertexColorBuffer.itemSize = 4;
		//24 color values (we have 24 vertices to color...)
        cubeVertexColorBuffer.numItems = 24;

		//Index Buffer Object
		//it joins sets of vertices into faces
        cubeVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        var cubeVertexIndices = [
		//this numbers are positions in the VBO array above
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
        //we have one item - the cube
		cubeVertexIndexBuffer.itemSize = 1;
		//we have 36 indices (6 faces, every face has 2 triangles, each triangle 3 vertices: 2x3x6=36)
        cubeVertexIndexBuffer.numItems = 36;
    }

	//Helper Variables
   // var rCube = 0;
	
	
	//var swinging = 0.01;

	
	
	//For every frame this function draws the complete scene from the beginning
    function drawScene2() {
	//the viewport gets the canvas values (that were assigned to the gl context variable)
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
		//the frame and depth buffers get cleaned (the depth buffer is used for sorting fragments)
		//without the depth buffer WebGL does not know which fragment is visible for a given pixel
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

		//the projection matrix (pMatrix) is set
		//45 degrees Field-Of-View
		//aspect ratio gl.viewportWidth / gl.viewportHeight
		//near plane: 0.1 , far plane: 100
        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

		//the modelview Matrix is initialized with the Identity Matrix
        mat4.identity(mvMatrix);
		
		//the ModelView matrix gets a global transformation ("camera" retracts 8 units)
		//otherwise the "camera" will be inside the rotating cube
		//z-axis points out of the screen. we translate -8 which is the inverse transform
		//in essence we move the world -8 units to have the camera 8 units forward.
		//REMEMBER there is no actual camera in WebGL
		mat4.translate(mvMatrix, [0.0, 0.0, -40.0]);
		
		
		//Keyboard controlled cube
		//we use the matrix stack to employ a local transformation to the cube
		mvPushMatrix();
     	//a translation associated with the keyboard
		mat4.translate(mvMatrix, [xTrans, yTrans, 0.0]);
     	//a rotation connected with animation parameters
        mat4.rotate(mvMatrix, degToRad(rCube), [0, 1, 0]);
		/*********************************************/
		//BIND BUFFERS!!!!!!!!!!!!
		//MUST BE DONE ONCE BEFORE DRAWING AN OBJECT
		/************************************************/
		//we bind the buffer for the cube vertices
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
		//we bind the buffer for the cube colors
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, cubeVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
		//we bind the buffer for the cube vertex indices
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
		/********************************************************************/
		//we update the uniforms for the shaders
        setMatrixUniforms();
		//we call the Draw Call of WebGL to draw the cube
		//Triangles mode
        gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		mvPopMatrix();

		
		//Instantiation of 25 cubes with absolute coordinates
		for (var i = 0; i < 5; i++){
		for (var y = 0; y < 5; y++){
			mvPushMatrix();
			mat4.translate(mvMatrix, [i + i* 2.0, 6  , y + y*2.0 ]);
			setMatrixUniforms();
			gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
			mvPopMatrix();
		}
		}

		//Draw swinging cube
		mvPushMatrix();
		mat4.translate(mvMatrix, [swinging, -3.5  , 0.0]);
		setMatrixUniforms();
		gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		mvPopMatrix();
		
		//Draw animating scaling (on y-axis) cube. aftos edw einai
		mvPushMatrix();
		mat4.translate(mvMatrix, [0.0, -15.5  , 0.0]);
		mat4.scale(mvMatrix, [0.5, 0.5, 0.5 ]);
		setMatrixUniforms();
		gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		mvPopMatrix();
		
		//Draw cube rotating on an edge
		mvPushMatrix();
		//mat4.translate(mvMatrix, [0.0, -13.0  , 0.0]);
		
			//Move pivot point to an edge
		//	mat4.translate(mvMatrix, [1.0, 1.0  , 0.0]);
		//	mat4.rotate(mvMatrix, degToRad(rCube), [0, 0, 1]);
		//	mat4.translate(mvMatrix, [-1.0, -1.0  , 0.0]);
			
		//setMatrixUniforms();
		//gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		//mvPopMatrix();

    }
	

	

	
//end of Javascript
</script>



</head>

<!-- HMTL for the canvas element-->
<body background="images/background.jpeg" onload="webGLStart();"> <!-- calls the entry point of our application -->
	<font color="white">
	<p>Welcome to Pacman!
	</p>
	Try and get all the pellets and avoid the ghosts. If you eat a power pellet,
	you will be invincible to the ghosts, <br>and you can eat them. This lasts for 10
	seconds.
	If you complete the stage succesfully, press spacebar to enter next level.
	
	<hr>
    <canvas id="TUCWebGL" style="border: none;" width="500" height="500"></canvas>
	<hr>
    
	<div id="site_content">
      <div id="sidebar_container">
        <div class="sidebar">
          <h3>Game Stats &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp Camera Modes</h3>	
          <h4>Score &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 1 - Panoramic &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 2 - Following </h4>
          	<p id="score_id"> 0 </p>
          <h4>Lifes</h4>
          	<p id="lives_id"> 3 </p>
		  <h4>Pellets Left</h4>
          	<p id="remainingPellets_id"> 96 </p>
        </div>
		
</body></html>